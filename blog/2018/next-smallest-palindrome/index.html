<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>Given a number, we have to find the next smallest <a href="https://en.wikipedia.org/wiki/Palindromic_number" rel="external nofollow noopener" target="_blank">palindrome</a> which is larger than this number.</p> <p>The input can be arbitrarily large. We’ll store the input in an array. e.g. if input is 1259, array will be, <code class="language-plaintext highlighter-rouge">int k[]= {1,2,5,9}</code>. To find the next smallest palindrome, we have to generalize the input. There can be three types of input,</p> <ul> <li>All digits are 9. e.g. 999</li> <li>Input is not a palindrome. e.g 12942</li> <li>The input itself a palindrome number. e.g. 1221 Algorithm for the first type is easy. Expand the array length by one and put boundary digits as 1 &amp; all other digits will be 0. <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Input:   999
Output: 1001
</code></pre></div> </div> </li> </ul> <h1 id="left-half--right-half">Left half &amp; Right half</h1> <p>Left half of 522665 is 522 and left half of 52123 is 52. Right half of 522665 is 665 &amp; right half of 52123 is 23.</p> <h2 id="iteration">Iteration</h2> <p>We’ll compare between left half and right half, starting from middle. For example, two variable i and j will indicate to 2 &amp; 4 respectively, if the input is 1 2 2 4 2 and i and j will indicate to 9 &amp; 3 respectively if the input is 5 6 9 3 2 5. For each iteration i will decrement and j will increment.</p> <p>Comparison outcomes. k[i] == k[j] if this is true, do nothing. k[i] &gt; k[j] if this is true, then stop comparing and just copy left half to right half. k[i] &lt; k[j] if this is true, follow the procedure below.</p> <p>Add and Copy: Add 1 to middle digit &amp; propagate carry to the left half and simultaneously copy left half to right half. Input: 5 2 1 1 6 5 n is even. so middle digit is 1 of left half. Perform (1+1) . summation 2, carry 0. X X 2 2 X X X 2 2 2 2 X 5 2 2 2 2 5</p> <p>Output: 5 2 2 2 2 5 Input: 1 2 9 4 5 middle digit is 9. add 1 to it. propagate carry to left half and copy to right half simultaneously. X X 0 X X X 3 0 3 X 1 3 0 3 1 Output: 1 3 0 3 1</p> <p>#type 3: For all iterations, k[i] == k[j]. It means the input is palindromic. To find the next smallest palindrome, follow the same procedure as before. add 1 to middle digit and copy from left to right simultaneously.</p> </body></html>